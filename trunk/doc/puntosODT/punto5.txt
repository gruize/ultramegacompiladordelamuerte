Programa → Decs & Is
    Programa.cod  = 
        inicio(Decs.n,Decs.dir) ||
        ir-a(Decs.etq)          ||
        Decs.cod                ||
        Is.cod                  ||
        stop
    Decs.etqh      = longInicio + 1
    Is.etqh        = Decs.etq
    Decs.dirh      = 0
    Decs.nh        = 0

Declaraciones → Declaraciones ; Declaracion
    Declaraciones0.ts       = añadeID(Declaraciones1.ts,Declaracion.id,Declaracion.props ⊗ Declaracion.propsop)
    Declaraciones1.dirh     = Declaraciones0.dirh
    Declaraciones0.dir      = Declaraciones1.dir + Declaracion.tam
    Declaracion.dirh        = Declaraciones1.dir
    Declaraciones1.nh       = Declaraciones0.nh
    Declaraciones0.n        = max(Declaraciones1.n,Declaracion.n)
    Declaraciones1.etqh     = Declaraciones0.etqh
    Declaracion.etqh        = Declaraciones1.etq
    Declaraciones0.etq      = Declaracion.etq
    Declaraciones0.cod      = Declaraciones1.cod || Declaracion.cod

Declaraciones → Declaracion
    Declaraciones.ts        = añadeID(creaTS(),Declaracion.id,Declaracion.props ⊗ Declaracion.propsop)
    Declaraciones.dir       = Declaraciones.dirh + Declaracion.tam
    Declaracion.dirh        = Declaraciones.dirh
    Declaracion.nh          = Declaraciones.nh
    Declaraciones.n         = Declaracion.n
    Declaracion.etqh        = Declaraciones.etqh
    Declaraciones.etq       = Declaracion.etq
    Declaraciones.cod       = Declaracion.cod


Declaracion → DecTipo
    Declaracion.propsop     = <>
    Declaracion.tam         = 0
    Declaracion.n           = Declaracion.nh
    Declaracion.cod         = λ
    Declaracion.etq         = Declaracion.etqh

Declaracion → DecVar
    DecVar.propsop          = <dir:Declaracion.dirh>
    Declaracion.tam         = DecVar.props.tipo.tam
    Declaracion.n           = Declaracion.nh
    Declaracion.cod         = λ
    Declaracion.etq         = Declaracion.etqh

Declaracion → DecProc
    DecProc.nh              = Declaracion.nh
    Declaracion.n           = DecProc.n
    DecProc.etqh            = Declaracion.etqh
    Declaracion.etq         = DecProc.etq
    Declaracion.cod         = DecProc.cod
    Declaracion.propsop     = DecProc.propsop


Tipo → Boolean
    Tipo.tipo = <t:boolean,tam:1>

Tipo → Character
    Tipo.tipo = <t:character,tam:1>

Tipo → Float
    Tipo.tipo = <t:float,tam:1>

Tipo → Natural
    Tipo.tipo = <t:natural,tam:1>

Tipo → Integer
    Tipo.tipo = <t:integer,tam:1>

Tipo → iden
    Tipo.tipo =
        <
            t:ref,
            id:iden.lex,
            tam:Tipo.tsh[iden.lex].tipo.tam
        >

Tipo → array [num] of Tipo
    Tipo.tipo =
        <
            t:array,
            nelems:valorDe(num.lex),
            tbase:Tipo.tipo,
            tam:valorDe(num.lex)*Tipo1.tipo.tam
        >

Tipo → ^Tipo
    Tipo0.tipo =
        <
            t:puntero,
            tbase:Tipo1.tipo,
            tam:1
        >

Tipo → reg Campos freg
    Tipo.tipo =
        <
            t:array,
            campos:Campos.campos,
            tam:Campos.tam
        >


Campos → Campos ; Campo
    Campos0.tam = Campos1.tam + Campo.tam
    Campo.desh  = Campos1.tam

Campos → Campo
    Campos.tam = Campo.tam
    Campo.desh = 0


Campo → iden: Tipo
    Campo.campo =
        <
            id:iden.lex,
            tipo:Tipo.tipo,
            desp:Campo.desph
        >
    Campo.tam   = Tipo.tam

DecProc → proc iden FParams Bloque fproc
    Bloque.dirh     = FParams.dir
    FParams.nh      = Bloque.nh = DecProc.nh + 1
    DecProc.n       = Bloque.n
    DecProc.cod     = Bloque.cod
    DecProc.propsop = <inicio:Bloque.inicio>
    Bloque.etqh     = DecProc.etqh
    DecProc.etq     = Bloque.etq
    Bloque.tsph     =
        añadeID(
            FParams.ts,
            DecProp.id,
            DecProc.props⊗{nivel:DecsProp.nh+1}⊗DecProc.propsop
        )


LAParams ::= LAParams, Expresion
    LAParams0.cod   =
        LAParams1.cod ||
        copia ||
        direccionParFormal(LAParams0.fparams[LAParams0.nparams]) ||
        Expresion.cod ||
        pasoParametro(Expresion.modo,LAParams0.fparams[LAParams0.nparams])
    LAParams1.etqh  = LAParams0.etqh
    Expresion.etqh  = LAParams1.etq + 1 + longDireccionParFormal
    LAParams0.etq   = Expresion.etq + longPasoParametro
    Expresion.parh  = LAParams0.fparamsh[LAParams0.nparams].modo == var

LAParams ::= Expresion
    LAParams.cod    =
        copia ||
        Expresion.cod ||
        pasoParametro(Expresion.modo,LAParams.fparams[1])
    Expresion.etqh  = LAParams.etq + 1
    LAParams.etq    = Expresion.etq + longPasoParametro
    Expresion.parh  = LAParams.fparamsh[1].modo == var


FParams → ( LFParams )
    FParams.dir = LFParams.dir

FParams → λ
    FParams.dir = 0


LFParams → LFParams, FParam
    LFParams0.ts    = añadeID(LFParams1.ts,FParam.id,
                           FParam.props ⊗ <dir:LFParams1.dir>)
    LFParams0.dir   = LFParams1.dir + FParam.tam
    FParam.dirh     = LFParams1.dir

LFParam → FParam
    LFParam.ts      = añadeID(LFParam.tsph, FParam.id,FParam.props ⊗ <dir:0>)
    LFParam.dir     = FParam.tam
    FParam.dirh     = 0


FParam → var iden: Tipo
    FParam.tam      = 1
    Fparam.param    = <modo: variable, tipo: Tipo.tipo, dir: Fparam.dirh>

FParam → id: Tipo
    FParam.tam      = Tipo.tipo.tam
    Fparam.param    = <modo: variable, tipo: Tipo.tipo, dir: Fparam.dirh>


Bloque → Decs && Ins
    Decs.dirh       = Bloque.dirh
    Decs.nh         = Bloque.nh
    Bloque.n        = Decs.n
    Decs.etqh       = Bloque.etqh
    Bloque.inicio   = Decs.etq
    Ins.etqh          = Decs.etq + longPrologo
    Bloque.etq      = Ins.etq + longEpilogo + 1
    Bloque.cod      =
            Decs.cod                    ||
            prologo(Bloque.nh,Decs.dir) ||
            Ins.cod                     ||
            epilogo(Bloque.nh)          ||
            ir-ind


Bloque → Ins
    Bloque.n        = Bloque.nh
    Bloque.cod      =
        prologo(Bloque.nh,Bloque.dirh)  ||
        Ins.cod                         ||
        epilogo(Bloque.nh)              ||
        ir-ind
    Ins.etqh        = Bloque.etqh + longPrologo
    Bloque.inicio   = Bloque.etqh
    Bloque.etq      = Ins.etq + longEpilogo + 1



Decs → Decs ; Dec
    Decs1.dirh = Decso.dirh

Decs → Dec
    Decs.dir = Decs.dirh + Dec.tam
    Dec.dirh = Decs.dirh

Inses → Ins ; Inses
    Inses0.cod    = Ins.cod || Inses1.cod
    Ins1.etqh     = Inses0.etqh
    Inses.etqh    = Ins1.etq
    Inses0.etq    = Ins.etq

Inses → Ins
    Inses.cod   = Ins.cod
    Ins.etqh    = Inses.etqh
    Inses.etq   = Ins.etq


Ins → InsL
    Inses.cod               = InsL.cod
    InsL.etqh     = Ins.etzqh
    Ins.etq                 = InsL.etq

Ins → InsLectura
    Ins.cod                 = InsLectura.cod
    InsLectura.etqh        = Ins.etqh
    Ins.etq                 = InsLectura.etq

Ins → InsEscritura
    Ins.cod                 = InsEscritura.cod
    InsEscritura.etqh      = Ins.etqh
    Ins.etq                 = InsEscritura.etq

Ins → InsCompuesta
    Ins.cod                 = InsCompuesta.cod
    InsCompuesta.etqh      = Ins.etqh
    Ins.etq                 = InsCompuesta.etq

Ins → InsIf
    Ins.cod                 = InsIf.cod
    InsIf.etqh   = Ins.etqh
    Ins.etq                 = InsIf.etq

Ins → InsWhile
    Ins.cod                 = InsWhile.cod
    InsWhile.etqh          = Ins.etqh
    Ins.etq                 = InsWhile.etq

Ins → InsFor
    Ins.cod                 = InsFor.cod
    InsFor.etqh            = Ins.etqh
    Ins.etq                 = InsFor.etq

Ins → InsNew
    Ins.cod                 = InsNew.cod
    InsNew.etqh            = Ins.etqh
    Ins.etq                 = InsNew.etq

Ins → InsDis
    Ins.cod                 = InsDis.cod
    InsDis.etqh = Ins.etqh
    Ins.etq                 = InsDis.etq

Ins → InsCall
    InsCall.etqh            = Ins.etqh
    Ins.etq                 = InsCall.etq
    Ins.cod                 = InsCall.cod

InsLectura → in(id)
    InsLectura.cod  = in InsLectura.tsh[id.lex].dir
    InsLectura.etq  = InsLectura.etqh + 1


InsEscritura → out(Expresion)
    InsEscritura.cod   = Expresion.cod || out
    Expresion.etqh           = InsEscritura.etqh
    InsEscritura.etq   = Expresion.etq + 1
    Expresion.parh           = false


InsAsignación → Mem := Expresion
    InsAsignación.cod =
        si esCompatibleConTipoBasico(Mem.tipo,Expresion.tsh)
            Mem.cod || Expresion.cod || desapila-ind
        si no
            Mem.cod || Expresion.cod || mueve(Mem.tipo.tam)
    Mem.etqh          = InsAsignación.etqh
    Expresion.etqh          = Mem.etq
    InsAsignación.etq = Expresion.etq + 1
    Expresion.parh          = false


InsCompuesta → { Is }
    InsCompuesta.cod    = Is.cod
    Is.etqh             = InsCompuesta.etqh
    InsCompuesta.etq    = Is.etq


InsIf → if Expresion then I Pelse
    InsIf.cod       =
        Expresion.cod || ir-f(I.etq + 1) || I.cod || ir-a(PElse.etq) || PElse.cod
    Expresion.etqh  = InsIf.etqh
    I.etqh          = Expresion.etq + 1
    PElse.etqh      = I.etq + 1
    InsIf.etq       = PElse.etq
    Expresion.parh  = false


PElse → else I
    PElse.cod  = I.cod
    PElse.etq  = I.etq
    I.etqh     = PElse.etqh

PElse → λ
    PElse.cod  = λ
    PElse.etq  = PElse.etqh


InsWhile → while Expresion do I
    InsWhile.cod   =
        Expresion.cod ||
        ir-f(I.etq + 1) ||
        I.cod ||
        ir-a(InsWhile.etqh)
    Expresion.etqh = InsWhile.etqh
    I.etqh         = Expresion.etq + 1
    InsWhile.etq   = I.etq + 1


InsFor → for id=Expresion to Expresion do I
    InsFor.cod  =
        Expresion0.cod ||
        desapila-dir InsFor.tsh[id.lex].dir ||
        Expresion1.cod ||
        dup ||
        apila-dir InsFor.tsh[id.lex].dir ||
        igual ||
        ir-v( InsFor.etq - 1) ||
        I.cod ||
        apila-dir InsFor.tsh[id.lex].dir ||
        apilar 1 ||
        sumar ||
        desapila-dir InsFor.tsh[id.lex].dir ||
        ir-a (Expresion1.etq)
        pop
    Expresion0.etqh   = InsFor.etqh
    Expresion1.etqh   = Expresion0.etq + 1
    I.etqh            = Expresion1.etq + 4
    InsFor.etq        = I.etq + 6


INew → new Mem
    INew.cod =
        Mem.cod ||
        new(
            si Mem.tipo.tbase = ref
                INew.tsh[Mem.tipo.tbase.id].tam
            si no
                1
        )
        || desapila-ind
    Mem.etqh = INew.etqh
    INew.etq = Mem.etq + 2


IDel → delete Mem
    IDel.cod =
        Mem.cod ||
        del(
            si Mem.tipo.tbase = ref
                IDel.tsh[Mem.tipo.tbase.id].tam
            si no
                1
        )
    Mem.etqh = IDel.etqh
    IDel.etq = Mem.etq + 1


ICall → iden AParams
    ICall.cod       =
        apila-ret(ICall.etq)    ||
        AParams.cod             ||
        ir-a(ICall.tsh[iden.lex].inicio)
    AParams.etqh    = Icall.etqh + longApilaRet
    ICall.etq       = AParams.etq + 1


AParams → LAparams
    AParams.cod     = inicio-paso || LAParams.cod || fin-paso
    LAParams.etqh   = AParams.etqh + longInicioPaso
    AParams.etq     = LAParams.etq + longFinPaso

AParams → λ
    AParams.cod     = λ
    AParams.etq     = AParams.etqh

Mem → id
    Mem.cod    = accesoVar(Mem.tsh[id.lex])
    Mem.etq    = Mem.etqh + longAccesoVar(Mem.tsh[id.lex])

Mem → Mem->
    Mem0.cod   = Mem1.cod || apila-ind
    Mem1.etqh  = Mem0.etqh
    Mem0.etq   = Mem1.etq + 1

Mem → Mem[Expresion]
    Mem0.cod        =
        Mem1.cod || Expresion.cod || apila Mem1.tipo.tbase.tam || multiplica || suma
    Mem1.etqh       = Mem0.etqh
    Expresion.etqh  = Mem1.etq
    Mem0.etq        = Expresion.etq + 3

Mem → Mem.id
    Mem0.cod   = Mem1.cod || apila(Mem1.tipo.campos[iden.lex].desp) || suma
    Mem1.etqh  = Mem0.etqh
    Mem0.etq   = Mem1.etq + 2

Expresion → ExpresionNivel1 OpNiv0 ExpresionNivel1
    Expresion.cod         =
        apilarTiposIgualados(ExpresionNivel10.cod,ExpresionNivel10.tipo,ExpresionNivel11.cod,ExpresionNivel11.tipo) ||
        case (OpNiv0.op)
            menor:
                menor
            mayor
                mayor
            menor-ig
                menorIg
            mayor-ig
                mayorIg
            igual
                igual
            no-igual
                no-igual
    ExpresionNivel10.etqh   = Expresion.etqh
    ExpresionNivel11.etqh   = ExpresionNivel10.etqh
    Expresion.etq           = ExpresionNivel11.etq
    Expresion.modo          = val
    ExpresionNivel10.parh   = ExpresionNivel11.parh = false

Expresion → ExpresionNivel1
    Expresion.cod           = ExpresionNivel1.cod
    ExpresionNivel1.etqh    = Expresion.etqh
    Expresion.etq           = ExpresionNivel1.etq
    Expresion.modo          = ExpresionNivel1.modo
    ExpresionNivel1.parh    = Expresion.parh

ExpresionNiv1 → ExpresionNiv1 or ExpresionNiv2
    ExpresionNiv10.cod  =
        ExpresionNiv11.cod ||
        dup ||
        ir-v(ExpresionNiv2.etqP) ||
        desapila ||
        ExpresionNiv2.cod
    ExpresionNiv11.etqh = ExpresionNiv10.etqh
    ExpresionNiv2.etqh  = ExpresionNiv11.etq + 3
    ExpresionNiv10.etq  = ExpresionNiv2.etq
    ExpresionNiv1.modo  = val
    ExpresionNiv11.parh = ExpresionNiv2.parh = false

ExpresionNiv1 → ExpresionNiv1 OpNiv1 ExpresionNiv2
    ExpresionNiv10.cod =
        apilarTiposIgualados(ExpresionNiv11.cod,ExpresionNiv11.tipo,ExpresionNiv2.cod,ExpresionNiv2.tipo) ||
        case (OpNiv1.op)
            suma:
                sumar
            resta:
                restar
    ExpresionNiv11.etqh = ExpresionNiv10.etqh
    ExpresionNiv2.etqh  =
        ExpresionNiv11.etq + longTrasCod1ApilarTiposIgualados(ExpresionNiv11.tipo,ExpresionNiv2.tipo)
    ExpresionNiv10.etq  =
        ExpresionNiv2.etq + longTrasCod2ApilarTiposIgualados(ExpresionNiv11.tipo,ExpresionNiv2.tipo)
    ExpresionNiv1.modo  = val
    ExpresionNiv11.parh = ExpresionNiv2.parh = false

ExpresionNiv1 → ExpresionNiv2
    ExpresionNiv1.cod  = ExpresionNiv2.cod
    ExpresionNiv2.etqh = ExpresionNiv1.etqh
    ExpresionNiv1.etq  = ExpresionNiv2.etq
    ExpresionNiv1.modo = ExpresionNiv2.modo
    ExpresionNiv2.parh = ExpresionNiv1.parh

ExpresionNiv2 ::= ExpresionNiv2 and ExpresionNiv3
    ExpresionNiv20.cod    =
        ExpresionNiv21.cod ||
        ir-f(Fact.etq + 1) ||
        Fact.cod ||
        ir-a(Fact.etq + 2) ||
        apila(0)
    ExpresionNiv21.etqh   = ExpresionNiv20.etqh
    Fact.etqh       = ExpresionNiv21.etq + 1
    ExpresionNiv20.etq    = Fact.etq + 2
    ExpresionNiv20.modo   = val
    ExpresionNiv21.parh   = ExpresionNiv3.parh = false

ExpresionNiv2 → ExpresionNiv2 OpNiv2 ExpresionNiv3
    ExpresionNiv20.cod    =
        case(OpNiv2.op)
            Multiplica:
                apilarTiposIgualados(
                    ExpresionNiv21.cod,
                    ExpresionNiv21.tipo,
                    ExpresionNiv3.cod,
                    ExpresionNiv3.tipo
                ) ||
                Mul
            Divide:
                apilarTiposIgualados(
                    ExpresionNiv21.cod,
                    ExpresionNiv21.tipo,
                    ExpresionNiv3.cod,
                    ExpresionNiv3.tipo
                ) ||
                Div
            Modulo:
                ExpresionNiv21.cod || ExpresionNiv3.cod || Mod
            y:
                ExpresionNiv21.cod || ExpresionNiv3.cod || Y
    ExpresionNiv21.etqh   = ExpresionNiv20.etqh
    ExpresionNiv3.etqh    =
        si OpNiv2.op == Multiplica \/ OpNiv2.op == Divide
            ExpresionNiv21.etq +
            longTrasCod1ApilarTiposIgualados(ExpresionNiv21.tipo,ExpresionNiv3.tipo)
        si no
            ExpresionNiv21.etq
    ExpresionNiv20.etq    =
        si OpNiv2.op == Multiplica \/ OpNiv2.op == Divide
            ExpresionNiv3.etq +
            longTrasCod2ApilarTiposIgualados(ExpresionNiv21.tipo,ExpresionNiv3.tipo)
        si no
            ExpresionNiv3.etq
    ExpresionNiv20.modo   = val
    ExpresionNiv21.parh   = ExpresionNiv3.parh = false

ExpresionNiv2 → ExpresionNiv3
    ExpresionNiv3.etqh    = ExpresionNiv2.etqh
    ExpresionNiv2.etq     = ExpresionNiv3.etq
    ExpresionNiv2.cod     = ExNiv3.cod
    ExpresionNiv20.modo   = ExpresionNiv3.modo
    ExpresionNiv3.parh    = ExpresionNiv2.parh;

ExpresionNiv3 → ExpresionNiv4 OpNiv3 ExpresionNiv3
    ExpresionNiv30.cod  =
        case (OpNiv3.op)
            shl:
                ExpresionNiv4.cod || ExpresionNiv31.cod || shl
            shr:
                ExpresionNiv4.cod || ExpresionNiv31.cod || shr
    ExpresionNiv30.modo = val
    ExpresionNiv4.etqh  = ExpresionNiv30.etqh
    ExpresionNiv31.etqh = ExpresionNiv4.etq
    ExpresionNiv30.etqh = ExpresionNiv31.etq + 1
    ExpresionNiv4.parh  = ExpresionNiv31.parh = false

ExpresionNiv3 → ExpresionNiv4
    ExpresionNiv4.etqh = ExpresionNiv3.etqh
    ExpresionNiv3.etq  = ExpresionNiv4.etq
    ExpresionNiv3.cod  = ExpresionNiv4.cod
    ExpresionNiv3.modo = ExpresionNiv4.modo
    ExpresionNiv4.parh = ExpresionNiv3.parh

ExpresionNiv4 → OpNiv4 ExpresionNiv4
    ExpresionNiv40.cod =
        case (OpNiv4.op)
            no:
                ExpresionNiv41.cod || no
            negativo:
                ExpresionNiv41.cod || negativo
            cast-float:
                ExpresionNiv41.cod || CastFloat
            cast-int:
                ExpresionNiv41.cod || CastInt
            cast-nat:
                ExpresionNiv41.cod || CastNat
            cast-char:
                ExpresionNiv41.cod || CastChar
    ExpresionNiv40.modo = val
    ExpresionNiv41.etqh = ExpresionNiv4.etqh
    ExpresionNiv40.etq  = ExpresionNiv41.etq + 1
    ExpresionNiv41.parh = false

ExpresionNiv4 → | Expresion |
    ExpresionNiv4.cod  = Expresion.cod || abs
    ExpresionNiv4.modo = Expresion.val
    Expresion.etqh     = ExpresionNiv4.etqh
    ExpresionNiv4.etq  = Expresion.etq
    Expresion.parh     = false

ExpresionNiv4 → ( Expresion )
    ExpresionNiv4.cod  = Expresion.cod
    ExpresionNiv4.modo = Expresion.modo
    Expresion.etqh     = ExpresionNiv4.etqh
    ExpresionNiv4.etq  = Expresion.etq
    Expresion.parh     = ExpresionNiv4.parh

ExpresionNiv4 → Literal
    ExpresionNiv4.cod  = Literal.cod
    ExpresionNiv4.modo = var
    Literal.etqh = ExpresionNiv4.etqh
    ExpresionNiv4.etq  = Literal.etq

ExpresionNiv4 → Mem
    ExpresionNiv4.cod    =
        si esCompatibleConTipoBasico(Mem.tipo,ExpresionNiv4.tsh) /\ not ExpresionNiv4.parh
            Mem.cod || apila-ind
        si no
            Mem.cod
    Mem.etqh        = ExpresionNiv4.etqh
    ExpresionNiv4.etq     =
        si esCompatibleConTipoBasico(Mem.tipo,ExpresionNiv4.tsh) /\ not ExpresionNiv4.parh
            Mem.etq + 1
        si no
            Mem.etq
    ExpresionNiv4.modo    = var


Literal → litNat
    Literal.cod = apila LitNat.lex
    Literal.etq = Literal.etqh + 1
    
Literal → litFlo
    Literal.cod = apila litFlo.lex
    Literal.etq = Literal.etqh + 1
    
Literal → litTrue
    Literal.cod = apila true
    Literal.etq = Literal.etqh + 1
    
Literal → litFalse
    Literal.cod = apila false
    Literal.etq = Literal.etqh + 1
    
Literal → litCha
    Literal.cod = apila litCha.lex
    Literal.etq = Literal.etqh + 1
    
