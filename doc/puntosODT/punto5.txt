Programa → Decs & Is
    Programa.cod  = 
        inicio(Decs.n,Decs.dir) ||
        ir-a(Decs.etq)          ||
        Decs.cod                ||
        Is.cod                  ||
        stop
    Decs.etqh      = longInicio + 1
    Is.etqh        = Decs.etq
    Decs.dirh      = 0
    Decs.nh        = 0

Decs → Decs ; Dec
    Decs0.ts        = añadeID(Decs1.ts,Dec.id,Dec.props ⊗ Dec.propsop)
    Decs1.dirh      = Decs0.dirh
    Decs0.dir       = Decs1.dir + Dec.tam
    Dec.dirh        = Decs1.dir
    Decs1.nh        = Decs0.nh
    Decs0.n         = max(Decs1.n,Dec.n)    
    Decs1.etqh      = Decs0.etqh
    Dec.etqh        = Decs1.etq
    Decs0.etq       = Dec.etq
    Decs0.cod       = Decs1.cod || Dec.cod

Decs → Dec
    Decs.ts         = añadeID(creaTS(),Dec.id,Dec.props ⊗ Dec.propsop)
    Decs.dir        = Decs.dirh + Dec.tam
    Dec.dirh        = Decs.dirh
    Dec.nh          = Decs.nh
    Decs.n          = Dec.n
    Dec.etqh        = Decs.etqh
    Decs.etq        = Dec.etq
    Decs.cod        = Dec.cod


Dec → DecTipo
    Dec.propsop     = <>
    Dec.tam         = 0
    Dec.n           = Dec.nh
    Dec.cod         = λ
    Dec.etq         = Dec.etqh
    
Dec → DecVar
    DecVar.propsop  = <dir:Dec.dirh>
    Dec.tam         = DecVar.props.tipo.tam
    Dec.n           = Dec.nh
    Dec.cod         = λ
    Dec.etq         = Dec.etqh
    
Dec → DecProc
    DecProc.nh      = Dec.nh
    Dec.n           = DecProc.n
    DecProc.etqh    = Dec.etqh
    Dec.etq         = DecProc.etq
    Dec.cod         = DecProc.cod
    Dec.propsop     = DecProc.propsop


Tipo → Boolean
    Tipo.tipo = <t:boolean,tam:1>

Tipo → Character
    Tipo.tipo = <t:character,tam:1>

Tipo → Float
    Tipo.tipo = <t:float,tam:1>

Tipo → Natural
    Tipo.tipo = <t:natural,tam:1>

Tipo → Integer
    Tipo.tipo = <t:integer,tam:1>

Tipo → iden
    Tipo.tipo =
        <   
            t:ref,
            id:iden.lex,
            tam:Tipo.tsh[iden.lex].tipo.tam
        >

Tipo → array [num] of Tipo
    Tipo.tipo =
        <
            t:array,
            nelems:valorDe(num.lex),
            tbase:Tipo.tipo,
            tam:valorDe(num.lex)*Tipo1.tipo.tam
        >

Tipo → ^Tipo
    Tipo0.tipo = 
        <
            t:puntero,
            tbase:Tipo1.tipo,
            tam:1
        >

Tipo → reg Campos freg
    Tipo.tipo = 
        <
            t:array,
            campos:Campos.campos,
            tam:Campos.tam
        >


Campos → Campos ; Campo
    Campos0.tam = Campos1.tam + Campo.tam
    Campo.desh  = Campos1.tam

Campos → Campo
    Campos.tam = Campo.tam
    Campo.desh = 0


Campo → iden: Tipo
    Campo.campo = 
        <
            id:iden.lex,
            tipo:Tipo.tipo,
            desp:Campo.desph
        >
    Campo.tam   = Tipo.tam

DecProc → proc iden FParams Bloque fproc
    Bloque.dirh     = FParams.dir
    FParams.nh      = Bloque.nh = DecProc.nh + 1
    DecProc.n       = Bloque.n
    DecProc.cod     = Bloque.cod
    DecProc.propsop = <inicio:Bloque.inicio>
    Bloque.etqh     = DecProc.etqh
    DecProc.etq     = Bloque.etq
    Bloque.tsph     = 
        añadeID(
            FParams.ts,
            DecProp.id,
            DecProc.props⊗{nivel:DecsProp.nh+1}⊗DecProc.propsop
        )
    

LAParams ::= LAParams, Exp
    LAParams0.cod   = 
        LAParams1.cod ||
        copia ||
        direccionParFormal(LAParams0.fparams[LAParams0.nparams]) ||
        Exp.cod ||
        pasoParametro(Exp.modo,LAParams0.fparams[LAParams0.nparams])
    LAParams1.etqh  = LAParams0.etqh
    Exp.etqh        = LAParams1.etq + 1 + longDireccionParFormal
    LAParams0.etq   = Exp.etq + longPasoParametro
    Exp.parh        = LAParams0.fparamsh[LAParams0.nparams].modo == var

LAParams ::= Exp
    LAParams.cod    = 
        copia ||
        Exp.cod ||
        pasoParametro(Exp.modo,LAParams.fparams[1])
    Exp.etqh        = LAParams.etq + 1
    LAParams.etq    = Exp.etq + longPasoParametro
    Exp.parh        = LAParams.fparamsh[1].modo == var

    
FParams → ( LFParams )
    FParams.dir = LFParams.dir
    
FParams → λ
    FParams.dir = 0


LFParams → LFParams, FParam
    LFParams0.ts    = añadeID(LFParams1.ts,FParam.id,
                           FParam.props ⊗ <dir:LFParams1.dir>)
    LFParams0.dir   = LFParams1.dir + FParam.tam
    FParam.dirh     = LFParams1.dir

LFParam → FParam
    LFParam.ts      = añadeID(LFParam.tsph, FParam.id,FParam.props ⊗ <dir:0>)
    LFParam.dir     = FParam.tam
    FParam.dirh     = 0


FParam → var iden: Tipo
    FParam.tam      = 1
    Fparam.param    = <modo: variable, tipo: Tipo.tipo, dir: Fparam.dirh>
    
FParam → id: Tipo
    FParam.tam      = Tipo.tipo.tam
    Fparam.param    = <modo: variable, tipo: Tipo.tipo, dir: Fparam.dirh>


Bloque → Decs && I
    Decs.dirh       = Bloque.dirh
    Decs.nh         = Bloque.nh
    Bloque.n        = Decs.n
    Decs.etqh       = Bloque.etqh
    Bloque.inicio   = Decs.etq
    I.etqh          = Decs.etq + longPrologo
    Bloque.etq      = I.etq + longEpilogo + 1
    Bloque.cod      = 
            Decs.cod                    || 
            prologo(Bloque.nh,Decs.dir) ||
            I.cod                       ||
            epilogo(Bloque.nh)          ||
            ir-ind


Bloque → I
    Bloque.n        = Bloque.nh
    Bloque.cod      = 
        prologo(Bloque.nh,Bloque.dirh)  ||
        I.cod                           ||
        epilogo(Bloque.nh)              ||
        ir-ind
    I.etqh          = Bloque.etqh + longPrologo
    Bloque.inicio   = Bloque.etqh
    Bloque.etq      = I.etq + longEpilogo + 1

    
    
Decs → Decs ; Dec
    Decs1.dirh = Decso.dirh
    
Decs → Dec
    Decs.dir = Decs.dirh + Dec.tam
    Dec.dirh = Decs.dirh

Is → I ; Is
    Is0.cod    = I.cod || Instrucciones1.cod
    Is1.etqh   = Is0.etqh
    I.etqh     = Is1.etq
    Is0.etq    = I.etq

Is → I
    Is.cod = I.cod
    I.etqh = Is.etqh
    Is.etq = I.etq


I → InsAsignación
    Is.cod             = InsAsignación.cod
    InsAsignación.etqh = I.etqh
    I.etq              = InsAsignación.etq

I → InsLectura
    I.cod              = InsLectura.cod
    InsLectura.etqh    = I.etqh
    I.etq              = InsLectura.etq

I → InsEscritura
    I.cod              = InsEscritura.cod
    InsEscritura.etqh  = I.etqh
    I.etq              = InsEscritura.etq

I → InsCompuesta
    I.cod              = InsCompuesta.cod
    InsCompuesta.etqh  = I.etqh
    I.etq              = InsCompuesta.etq

I → InsIf
    I.cod          = InsIf.cod
    InsIf.etqh     = I.etqh
    I.etq          = InsIf.etq

I → InsWhile
    I.cod          = InsWhile.cod
    InsWhile.etqh  = I.etqh
    I.etq          = InsWhile.etq

I → InsFor
    I.cod          = InsFor.cod
    InsFor.etqh    = I.etqh
    I.etq          = InsFor.etq

I → InsNew
    I.cod          = InsNew.cod
    InsNew.etqh    = I.etqh
    I.etq          = InsNew.etq

I → InsDis
    I.cod          = InsDis.cod
    InsDis.etqh    = I.etqh
    I.etq          = InsDis.etq

I → ICall
    ICall.etqh  = I.etqh
    I.etq       = ICall.etq
    I.cod       = ICall.cod

InsLectura → in(id)
    InsLectura.cod  = in InsLectura.tsh[id.lex].dir
    InsLectura.etq  = InsLectura.etqh + 1


InsEscritura → out(Exp)
    InsEscritura.cod   = Exp.cod || out
    Exp.etqh           = InsEscritura.etqh
    InsEscritura.etq   = Exp.etq + 1
    Exp.parh           = false
    

InsAsignación → Mem := Exp
    InsAsignación.cod =
        si esCompatibleConTipoBasico(Mem.tipo,Exp.tsh)
            Mem.cod || Exp.cod || desapila-ind
        si no
            Mem.cod || Exp.cod || mueve(Mem.tipo.tam)
    Mem.etqh          = InsAsignación.etqh
    Exp.etqh          = Mem.etq
    InsAsignación.etq = Exp.etq + 1
    Exp.parh          = false
    

InsCompuesta → { Is }
    InsCompuesta.cod    = Is.cod
    Is.etqh             = InsCompuesta.etqh
    InsCompuesta.etq    = Is.etq
    

InsIf → if Exp then I Pelse
    InsIf.cod   =
        Exp.cod || ir-f(I.etq + 1) || I.cod || ir-a(PElse.etq) || PElse.cod
    Exp.etqh    = InsIf.etqh
    I.etqh      = Exp.etq + 1
    PElse.etqh  = I.etq + 1
    InsIf.etq   = PElse.etq
    Exp.parh    = false


PElse → else I
    PElse.cod  = I.cod
    PElse.etq  = I.etq
    I.etqh     = PElse.etqh

PElse → λ
    PElse.cod  = λ
    PElse.etq  = PElse.etqh


InsWhile → while Exp do I
    InsWhile.cod   =
        Exp.cod ||
        ir-f(I.etq + 1) ||
        I.cod ||
        ir-a(InsWhile.etqh)
    Exp.etqh       = InsWhile.etqh
    I.etqh         = Exp.etq + 1
    InsWhile.etq   = I.etq + 1


InsFor → for id=Exp to Exp do I
    InsFor.cod  =
        Exp0.cod ||
        desapila-dir InsFor.tsh[id.lex].dir ||
        Exp1.cod ||
        dup ||
        apila-dir InsFor.tsh[id.lex].dir ||
        igual ||
        ir-v( InsFor.etq - 1) ||
        I.cod ||
        apila-dir InsFor.tsh[id.lex].dir ||
        apilar 1 ||
        sumar ||
        desapila-dir InsFor.tsh[id.lex].dir ||
        ir-a (Exp1.etq)
        pop
    Exp0.etqh   = InsFor.etqh
    Exp1.etqh   = Exp0.etq + 1
    I.etqh      = Exp1.etq + 4
    InsFor.etq  = I.etq + 6


INew → new Mem
    INew.cod = 
        Mem.cod ||
        new(
            si Mem.tipo.tbase = ref
                INew.tsh[Mem.tipo.tbase.id].tam
            si no 
                1
        )
        || desapila-ind
    Mem.etqh = INew.etqh
    INew.etq = Mem.etq + 2

    
IDel → delete Mem
    IDel.cod = 
        Mem.cod ||
        del(
            si Mem.tipo.tbase = ref
                IDel.tsh[Mem.tipo.tbase.id].tam
            si no
                1
        )
    Mem.etqh = IDel.etqh
    IDel.etq = Mem.etq + 1


ICall → iden AParams
    ICall.cod       = 
        apila-ret(ICall.etq)    ||
        AParams.cod             ||
        ir-a(ICall.tsh[iden.lex].inicio)
    AParams.etqh    = Icall.etqh + longApilaRet
    ICall.etq       = AParams.etq + 1


AParams → LAparams
    AParams.cod     = inicio-paso || LAParams.cod || fin-paso
    LAParams.etqh   = AParams.etqh + longInicioPaso
    AParams.etq     = LAParams.etq + longFinPaso

AParams → λ
    AParams.cod     = λ
    AParams.etq     = AParams.etqh
    
Mem → id
    Mem.cod    = accesoVar(Mem.tsh[id.lex])
    Mem.etq    = Mem.etqh + longAccesoVar(Mem.tsh[id.lex])
    
Mem → Mem->
    Mem0.cod   = Mem1.cod || apila-ind
    Mem1.etqh  = Mem0.etqh
    Mem0.etq   = Mem1.etq + 1
    
Mem → Mem[Expresion]
    Mem0.cod   =
        Mem1.cod || Exp.cod || apila Mem1.tipo.tbase.tam || multiplica || suma
    Mem1.etqh  = Mem0.etqh
    Exp.etqh   = Mem1.etq
    Mem0.etq   = Exp.etq + 3
    
Mem → Mem.id
    Mem0.cod   = Mem1.cod || apila(Mem1.tipo.campos[iden.lex].desp) || suma
    Mem1.etqh  = Mem0.etqh
    Mem0.etq   = Mem1.etq + 2 

Exp → ExpNiv1 OpNiv0 ExpNiv1
    Exp.cod         =
        apilarTiposIgualados(ExpNiv10.cod,ExpNiv10.tipo,ExpNiv11.cod,ExpNiv11.tipo) ||
        case (OpNiv0.op)
            menor:
                menor
            mayor
                mayor
            menor-ig
                menorIg
            mayor-ig
                mayorIg
            igual
                igual
            no-igual
                no-igual
    ExpNiv10.etqh   = Exp.etqh
    ExpNiv11.etqh   = ExpNiv10.etqh
    Exp.etq         = ExpNiv11.etq
    Exp.modo        = val 
    ExpNiv10.parh   = ExpNiv11.parh = false

Exp → ExpNiv1
    Exp.cod         = ExpNiv1.cod
    ExpNiv1.etqh    = Exp.etqh
    Exp.etq         = ExpNiv1.etq
    Exp.modo        = ExpNiv1.modo
    ExpNiv1.parh    = Exp.parh

ExpNiv1 → ExpNiv1 or ExpNiv2
    ExpNiv10.cod  = 
        ExpNiv11.cod || 
        dup || 
        ir-v(ExpNiv2.etqP) ||
        desapila || 
        ExpNiv2.cod
    ExpNiv11.etqh = ExpNiv10.etqh
    ExpNiv2.etqh  = ExpNiv11.etq + 3
    ExpNiv10.etq  = ExpNiv2.etq
    ExpNiv1.modo  = val
    ExpNiv11.parh = ExpNiv2.parh = false

ExpNiv1 → ExpNiv1 OpNiv1 ExpNiv2
    ExpNiv10.cod =
        apilarTiposIgualados(ExpNiv11.cod,ExpNiv11.tipo,ExpNiv2.cod,ExpNiv2.tipo) ||
        case (OpNiv1.op)
            suma:
                sumar
            resta:
                restar
    ExpNiv11.etqh = ExpNiv10.etqh
    ExpNiv2.etqh  = 
        ExpNiv11.etq + longTrasCod1ApilarTiposIgualados(ExpNiv11.tipo,ExpNiv2.tipo)
    ExpNiv10.etq  =
        ExpNiv2.etq + longTrasCod2ApilarTiposIgualados(ExpNiv11.tipo,ExpNiv2.tipo)
    ExpNiv1.modo  = val
    ExpNiv11.parh = ExpNiv2.parh = false

ExpNiv1 → ExpNiv2
    ExpNiv1.cod  = ExpNiv2.cod
    ExpNiv2.etqh = ExpNiv1.etqh
    ExpNiv1.etq  = ExpNiv2.etq
    ExpNiv1.modo = ExpNiv2.modo
    ExpNiv2.parh = ExpNiv1.parh

ExpNiv2 ::= ExpNiv2 and ExpNiv3
    ExpNiv20.cod    = 
        ExpNiv21.cod || 
        ir-f(Fact.etq + 1) || 
        Fact.cod || 
        ir-a(Fact.etq + 2) || 
        apila(0)
    ExpNiv21.etqh   = ExpNiv20.etqh
    Fact.etqh       = ExpNiv21.etq + 1
    ExpNiv20.etq    = Fact.etq + 2
    ExpNiv20.modo   = val
    ExpNiv21.parh   = ExpNiv3.parh = false
    
ExpNiv2 → ExpNiv2 OpNiv2 ExpNiv3
    ExpNiv20.cod    =
        case(OpNiv2.op)
            Multiplica:
                apilarTiposIgualados(
                    ExpNiv21.cod,
                    ExpNiv21.tipo,
                    ExpNiv3.cod,
                    ExpNiv3.tipo
                ) ||
                Mul
            Divide:
                apilarTiposIgualados(
                    ExpNiv21.cod,
                    ExpNiv21.tipo,
                    ExpNiv3.cod,
                    ExpNiv3.tipo
                ) ||
                Div
            Modulo:
                ExpNiv21.cod || ExpNiv3.cod || Mod
            y:
                ExpNiv21.cod || ExpNiv3.cod || Y
    ExpNiv21.etqh   = ExpNiv20.etqh
    ExpNiv3.etqh    = 
        si OpNiv2.op == Multiplica \/ OpNiv2.op == Divide
            ExpNiv21.etq + 
            longTrasCod1ApilarTiposIgualados(ExpNiv21.tipo,ExpNiv3.tipo)
        si no
            ExpNiv21.etq
    ExpNiv20.etq    = 
        si OpNiv2.op == Multiplica \/ OpNiv2.op == Divide
            ExpNiv3.etq + 
            longTrasCod2ApilarTiposIgualados(ExpNiv21.tipo,ExpNiv3.tipo)
        si no
            ExpNiv3.etq
    ExpNiv20.modo   = val
    ExpNiv21.parh   = ExpNiv3.parh = false
                
ExpNiv2 → ExpNiv3
    ExpNiv3.etqh    = ExpNiv2.etqh
    ExpNiv2.etq     = ExpNiv3.etq
    ExpNiv2.cod     = ExNiv3.cod
    ExpNiv20.modo   = ExpNiv3.modo
    ExpNiv3.parh    = ExpNiv2.parh;

ExpNiv3 → ExpNiv4 OpNiv3 ExpNiv3
    ExpNiv30.cod  =
        case (OpNiv3.op)
            shl:
                ExpNiv4.cod || ExpNiv31.cod || shl
            shr:
                ExpNiv4.cod || ExpNiv31.cod || shr
    ExpNiv30.modo = val
    ExpNiv4.etqh  = ExpNiv30.etqh
    ExpNiv31.etqh = ExpNiv4.etq
    ExpNiv30.etqh = ExpNiv31.etq + 1
    ExpNiv4.parh  = ExpNiv31.parh = false

ExpNiv3 → ExpNiv4
    ExpNiv4.etqh = ExpNiv3.etqh
    ExpNiv3.etq  = ExpNiv4.etq
    ExpNiv3.cod  = ExpNiv4.cod
    ExpNiv3.modo = ExpNiv4.modo
    ExpNiv4.parh = ExpNiv3.parh

ExpNiv4 → OpNiv4 ExpNiv4
    ExpNiv40.cod =
        case (OpNiv4.op)
            no:
                ExpNiv41.cod || no
            negativo:
                ExpNiv41.cod || negativo
            cast-float:
                ExpNiv41.cod || CastFloat
            cast-int:
                ExpNiv41.cod || CastInt
            cast-nat:
                ExpNiv41.cod || CastNat
            cast-char:
                ExpNiv41.cod || CastChar
    ExpNiv40.modo = val
    ExpNiv41.etqh = ExpNiv4.etqh
    ExpNiv40.etq  = ExpNiv41.etq + 1
    ExpNiv41.parh = false

ExpNiv4 → | Exp |
    ExpNiv4.cod  = Exp.cod || abs
    ExpNiv4.modo = Exp.val
    Exp.etqh     = ExpNiv4.etqh
    ExpNiv4.etq  = Exp.etq
    Exp.parh     = false

ExpNiv4 → ( Exp )
    ExpNiv4.cod  = Exp.cod
    ExpNiv4.modo = Exp.modo
    Exp.etqh     = ExpNiv4.etqh
    ExpNiv4.etq  = Exp.etq
    Exp.parh     = ExpNiv4.parh

ExpNiv4 → Literal
    ExpNiv4.cod  = Literal.cod
    ExpNiv4.modo = var
    Literal.etqh = ExpNiv4.etqh
    ExpNiv4.etq  = Literal.etq
    
ExpNiv4 → Mem
    ExpNiv4.cod    = 
        si esCompatibleConTipoBasico(Mem.tipo,ExpNiv4.tsh) /\ not ExpNiv4.parh
            Mem.cod || apila-ind
        si no
            Mem.cod
    Mem.etqh        = ExpNiv4.etqh
    ExpNiv4.etq     = 
        si esCompatibleConTipoBasico(Mem.tipo,ExpNiv4.tsh) /\ not ExpNiv4.parh
            Mem.etq + 1
        si no 
            Mem.etq
    ExpNiv4.modo    = var
    

Literal → litNat
    Literal.cod = apila LitNat.lex
    Literal.etq = Literal.etqh + 1
    
Literal → litFlo
    Literal.cod = apila litFlo.lex
    Literal.etq = Literal.etqh + 1
    
Literal → litTrue
    Literal.cod = apila true
    Literal.etq = Literal.etqh + 1
    
Literal → litFalse
    Literal.cod = apila false
    Literal.etq = Literal.etqh + 1
    
Literal → litCha
    Literal.cod = apila litCha.lex
    Literal.etq = Literal.etqh + 1
    
